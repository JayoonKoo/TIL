# 리눅스 파일 시스템과 쉘 명령어 

## 리눅스는 I/O 를 파일 처럼 처리한다. 
가상 파일 시스템을 사용한다. 

예를들어, tty 는 가상파일 시스템 인퍼에스로 가상 터미널 환경과 연결되어 있다. 
키보드 인풋을 받는다. 

## 슈퍼 블록, inode와 파일 
슈퍼 블록 : 파일 시스템의 정보 

파일 : inode 고유값과 자료구조에 의해 주요 정보를 관리한다. 
- 파일 이름:inode 파일이름은 inode 번호와 매칭
- 파일 시스템에서는 inode를 기반으로 파일 엑세스 
- inode 기반 메타 데이터 저장. (프로세스에서 PCB와 비슷하다.)

메타 데이터에는 파일 권한, 소유자 정보, 파일 사이즈, 생성 시간등 시간 관련 정보, 데이터 저장 위치 같은 정보가 적힌다. 

<img src="images/210821-리눅스%20프로세스/1.png" width="400">

## 파일과 inode
각 디렉토리에는 dentry 리 라고 하는 엔트리 정보가 있음. 
`/home/ubuntu/link.txt` 파일의 경우 / dentry 에서 home 서브 디릭토리를 찾고, home 에서 unbuntu를 찾고, ununtu에서 link.txt를 찾음.

디렉토리도 마찬가지로 inode를 갖고 있으므로 이를 통해 구별할 수 있다. 

## 하드 링크와 소프트 링크 
`cp` 파일 복사 : `-rf` 옵션을 많이 사용함. 폴더 안쪽 까지 모두 복사함.
`cp -rf programing/ programing2`

`rm` : 파일 삭제. `rm -rf ` 로 많이 사용함. 

바로가기 처럼 만들고 싶다? -> 링크 하고 싶다. 


### 하드링크 
`ln link.txt hard.txt` link.txt를 링크하는 hard.txt

하드 링크는 또다른 파일을 만드는 것인데 inode 구조체는 동일하게 된다. 복사와 다른 점은 복사는 inode 구조체까지 복사한다. 

`ls -i` 로 inode 값 확인 링크로 만들면 inode id 값이 같다. 

만약 link.txt를 변경하면 hard.txt 도 똑같이 변경된다. 

하드링크에 경우에는 원본 파일이 사라지는 경우에도 파일 내용은 그대로이다. 이것은 실제 파일 하고 가르키고 있는 inode 구조체가 분리 되어 있기 때문이다.

<img src="images/210813-리눅스%20파일시스템%20및%20쉘%20명령어/1.png" width="500">

이렇게 하면 좋은점? inode를 공유 하면서도 파일 복사 같이 되기 때문에 inode 구조체를 또 복사할 필요가 없다. 

### 소프트 링크 (심볼릭 링크)
윈도우에 바로가기 아이콘과 같다고 할 수 있다. 
원본 파일이 없어지면 접근이 안된다. 

소프트 링크는 indoe 값이 다르다. 소프트 링크는 l로 시작한다. 링크 파일임으로 원본 파일에 내용이 바뀌면 소프트 링크에 내용 도 바뀐다. but, 원본이 삭제되면 소프트 링크 파일도 사라진다. 

소프트 링크 같은 경우에는 별도의 inode structure을 갖는다. 다만, address 로 direct Block 을 갖는 것이 아니라 원본 파일을 가르키는 redirected path 를 갖는다. 

<img src="images/210813-리눅스%20파일시스템%20및%20쉘%20명령어/2.png" width="500">

## 특수 파일
리눅스는 모든것을 파일처럼 다루기 때문에 디바이스도 파일처럼 다룬다. 
- 블록 디바이스 (Block Device) : 저장 매체 등은 블록 단위로 데이터를 읽거나 써야 효율적이다. I/O 송수신 속도가 높다.
- 캐릭터 디바이스 (Charcter Device) : 캐릭터 디바이스는 굳이 블록단위로 데이터를 보내지 않아도 되는 경우로 byte 단위로 데이터를 전송하고 키보드나 마우스 같은 경우가 있다. I/O 송수신 속도가 낮음. 

b 로 시작하면 블록 디바이스 이다. 

c 로 시작하면 캐릭터 디바이스 이다. 
